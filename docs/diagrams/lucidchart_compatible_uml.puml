@startuml TurnkeyHMS_Architecture

!define EXTERNAL_SYSTEMS #E3F2FD
!define REACT_CONTEXTS #E8F5E8
!define SERVICES #FFF3E0
!define HOOKS #F3E5F5
!define COMPONENTS #FCE4EC

package "External Systems" EXTERNAL_SYSTEMS {
    class TurnkeyHMSAPI {
        - baseURL: String
        - version: String
        + getAnalytics(): Promise
        + getRevenue(): Promise
        + getSessions(): Promise
    }
    
    class WebSocketGateway {
        - url: String
        + connect(): Promise<void>
        + disconnect(): void
        + subscribe(event: String): void
        + emit(event: String, data: Object): void
    }
    
    class FirebaseAuth {
        + authenticate(credentials: Object): Promise<User>
        + refreshToken(): Promise<String>
        + logout(): Promise<void>
    }
}

package "React Contexts" REACT_CONTEXTS {
    class AuthContext {
        + user: User
        + isAuthenticated: Boolean
        + isLoading: Boolean
        + permissions: Permission[]
        + role: UserRole
        + login(email: String, password: String): Promise<void>
        + logout(): Promise<void>
        + hasPermission(permission: Permission): Boolean
        + canAccess(resource: String): Boolean
    }
    
    class WebSocketContext {
        + isConnected: Boolean
        + connectionStatus: ConnectionStatus
        + subscribe(event: String, handler: Function): void
        + unsubscribe(event: String, handler: Function): void
        + send(message: Object): void
        + reconnect(): void
    }
    
    class FilterContext {
        + timeRange: TimeRange
        + dateRange: DateRange
        + selectedProperties: String[]
        + searchQuery: String
        + customFilters: Object
        + setTimeRange(range: TimeRange): void
        + setDateRange(range: DateRange): void
        + toggleProperty(propertyId: String): void
        + clearFilters(): void
        + hasActiveFilters: Boolean
    }
}

package "Service Layer" SERVICES {
    abstract class BaseService {
        # apiClient: AxiosInstance
        # cache: CacheManager
        + initialize(): void
        + destroy(): void
        # handleError(error: Error): void
    }
    
    class APIService extends BaseService {
        + endpoints: Object
        + get(url: String): Promise<Object>
        + post(url: String, data: Object): Promise<Object>
        + put(url: String, data: Object): Promise<Object>
        + delete(url: String): Promise<Object>
    }
    
    class WebSocketService extends BaseService {
        - connection: WebSocket
        - eventEmitter: EventEmitter
        - messageQueue: Message[]
        - reconnectAttempts: Number
        + connect(): Promise<void>
        + disconnect(): void
        + subscribe(event: String, handler: Function): void
        + unsubscribe(event: String, handler: Function): void
        + send(message: Object): void
    }
    
    class CacheService extends BaseService {
        - cache: Map<String, CacheEntry>
        + get(key: String): Object
        + set(key: String, value: Object, ttl: Number): void
        + invalidate(key: String): void
        + clear(): void
    }
    
    class AuthService extends BaseService {
        + currentUser: User
        + isAuthenticated: Boolean
        + login(credentials: Object): Promise<User>
        + logout(): Promise<void>
        + refreshToken(): Promise<String>
        + getPermissions(): Permission[]
    }
}

package "Custom Hooks" HOOKS {
    class UseRealtimeData {
        + eventType: String
        + data: Object[]
        + latestData: Object
        + isConnected: Boolean
        + buffer: Object[]
        + clearBuffer(): void
    }
    
    class UseCacheFirst {
        + key: String
        + data: Object
        + isLoading: Boolean
        + isError: Boolean
        + error: Error
        + isStale: Boolean
        + refetch(): void
    }
    
    class UseWebSocket {
        + isConnected: Boolean
        + connectionStatus: ConnectionStatus
        + subscribe(event: String, handler: Function): void
        + unsubscribe(event: String, handler: Function): void
        + send(message: Object): void
    }
}

package "Feature Components" COMPONENTS {
    package "AI Insights" {
        class PredictiveModels {
            + props: PredictiveModelsProps
            + render(): ReactElement
            - calculatePredictions(): Prediction[]
            - formatData(): ChartData
        }
        
        class AnomalyDetection {
            + props: AnomalyDetectionProps
            + render(): ReactElement
            - detectAnomalies(): Anomaly[]
            - highlightAnomalies(): void
        }
        
        class UseMLPredictions {
            + predictions: Prediction[]
            + isLoading: Boolean
            + confidence: Number
            + refresh(): void
        }
    }
    
    package "Revenue Management" {
        class PricingOptimizer {
            + props: PricingOptimizerProps
            + render(): ReactElement
            - calculateOptimalPricing(): PriceRecommendation[]
            - validatePriceRules(): Boolean
        }
        
        class DemandForecast {
            + props: DemandForecastProps
            + render(): ReactElement
            - generateForecast(): ForecastData
            - calculateConfidenceIntervals(): ConfidenceInterval[]
        }
        
        class UsePricingEngine {
            + recommendations: PriceRecommendation[]
            + isOptimizing: Boolean
            + optimize(): void
            + applyRecommendations(): void
        }
    }
    
    package "Session Analytics" {
        class ConversionFunnel {
            + props: ConversionFunnelProps
            + render(): ReactElement
            - calculateConversionRates(): ConversionRate[]
            - identifyDropOffPoints(): DropOffPoint[]
        }
        
        class JourneyMap {
            + props: JourneyMapProps
            + render(): ReactElement
            - mapUserJourney(): JourneyStep[]
            - calculateTimeSpent(): Duration[]
        }
        
        class UseSessionData {
            + sessions: UserSession[]
            + activeSessions: UserSession[]
            + metrics: SessionMetrics
            + refresh(): void
        }
    }
}

package "Shared Components" COMPONENTS {
    abstract class BaseComponent {
        + props: ComponentProps
        + render(): ReactElement
        # handleError(error: Error): void
        # validateProps(): Boolean
    }
    
    class DataTable extends BaseComponent {
        + data: Object[]
        + columns: Column[]
        + sortable: Boolean
        + filterable: Boolean
        + onSort(column: String, direction: SortDirection): void
        + onFilter(filters: FilterCriteria): void
    }
    
    class LoadingStates extends BaseComponent {
        + type: LoadingType
        + message: String
        + progress: Number
        + render(): ReactElement
    }
    
    class ErrorBoundary extends BaseComponent {
        + hasError: Boolean
        + error: Error
        + componentDidCatch(error: Error, errorInfo: ErrorInfo): void
        + render(): ReactElement
    }
}

package "Layout Components" COMPONENTS {
    class DashboardShell extends BaseComponent {
        + children: ReactNode
        + sidebar: Boolean
        + navigation: NavigationConfig
        + render(): ReactElement
    }
    
    class NavigationBar extends BaseComponent {
        + user: User
        + notifications: Notification[]
        + onLogout(): void
        + render(): ReactElement
    }
    
    class TimeFilterControls extends BaseComponent {
        + timeRange: TimeRange
        + presets: TimePreset[]
        + onChange(range: TimeRange): void
        + render(): ReactElement
    }
}

package "Data Models" {
    class User {
        + id: String
        + email: String
        + name: String
        + role: UserRole
        + permissions: Permission[]
        + lastLogin: Date
    }
    
    class UserSession {
        + id: String
        + userId: String
        + startTime: Date
        + endTime: Date
        + events: SessionEvent[]
        + deviceInfo: DeviceInfo
        + location: Location
    }
    
    class SessionEvent {
        + id: String
        + type: EventType
        + timestamp: Date
        + data: Object
        + sessionId: String
    }
    
    enum UserRole {
        ADMIN
        MANAGER
        ANALYST
        VIEWER
    }
    
    enum EventType {
        PAGE_VIEW
        BOOKING_ATTEMPT
        BOOKING_COMPLETE
        SESSION_START
        SESSION_END
    }
    
    enum ConnectionStatus {
        CONNECTING
        CONNECTED
        DISCONNECTED
        ERROR
    }
}

' Relationships - External System Integration
AuthContext --> FirebaseAuth : "authenticates via"
WebSocketContext --> WebSocketGateway : "connects to"
FilterContext --> CacheService : "persists state in"

' Service Layer Relationships
APIService --> TurnkeyHMSAPI : "communicates with"
WebSocketService --> WebSocketGateway : "manages connection to"
AuthService --> FirebaseAuth : "integrates with"

' Hook Dependencies
UseRealtimeData --> WebSocketContext : "subscribes to events"
UseCacheFirst --> APIService : "fetches data via"
UseWebSocket --> WebSocketContext : "accesses connection"

' Feature Module Dependencies
PredictiveModels --> UseMLPredictions : "uses predictions from"
AnomalyDetection --> UseMLPredictions : "detects anomalies via"
PricingOptimizer --> UsePricingEngine : "optimizes pricing with"
DemandForecast --> UsePricingEngine : "forecasts demand via"
ConversionFunnel --> UseSessionData : "analyzes conversions with"
JourneyMap --> UseSessionData : "maps journeys using"

' Component Hierarchy
DataTable --|> BaseComponent : "extends"
LoadingStates --|> BaseComponent : "extends"
ErrorBoundary --|> BaseComponent : "extends"
DashboardShell --|> BaseComponent : "extends"
NavigationBar --|> BaseComponent : "extends"
TimeFilterControls --|> BaseComponent : "extends"

' Layout Composition
DashboardShell *-- NavigationBar : "contains"
DashboardShell *-- TimeFilterControls : "contains"

' Data Model Relationships
User --> UserRole : "has role"
UserSession *-- SessionEvent : "contains events"
SessionEvent --> EventType : "of type"
WebSocketContext --> ConnectionStatus : "has status"

@enduml

